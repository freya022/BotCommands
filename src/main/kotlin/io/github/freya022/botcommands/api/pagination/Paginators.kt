package io.github.freya022.botcommands.api.pagination

import io.github.freya022.botcommands.api.components.Button
import io.github.freya022.botcommands.api.components.Components
import io.github.freya022.botcommands.api.core.BContext
import io.github.freya022.botcommands.api.core.service.annotations.BService
import io.github.freya022.botcommands.api.core.service.annotations.Dependencies
import io.github.freya022.botcommands.api.pagination.custom.CustomPageEditor
import io.github.freya022.botcommands.api.pagination.custom.CustomPagination
import io.github.freya022.botcommands.api.pagination.custom.CustomPaginationBuilder
import io.github.freya022.botcommands.api.pagination.menu.AbstractMenuBuilder
import io.github.freya022.botcommands.api.pagination.menu.MenuBuilder
import io.github.freya022.botcommands.api.pagination.menu.buttonized.BlockingChoiceCallback
import io.github.freya022.botcommands.api.pagination.menu.buttonized.ButtonMenuBuilder
import io.github.freya022.botcommands.api.pagination.menu.buttonized.StyledButtonContentSupplier
import io.github.freya022.botcommands.api.pagination.menu.buttonized.SuspendingChoiceCallback
import io.github.freya022.botcommands.api.pagination.paginator.AbstractPaginator
import io.github.freya022.botcommands.api.pagination.paginator.Paginator
import io.github.freya022.botcommands.api.pagination.paginator.PaginatorBuilder
import io.github.freya022.botcommands.api.pagination.wrapper.PaginationWrapperBuilder
import io.github.freya022.botcommands.api.utils.ButtonContent

/**
 * Factory for multiple pagination types.
 */
@BService
@Dependencies(Components::class)
class Paginators(private val context: BContext) {
    /**
     * A single page generated by a [CustomPageEditor].
     *
     * This is primarily used in combination with [paginationWrapper].
     *
     * In an effort to reduce resource consumption,
     * you should call [AbstractPaginator.cleanup] when the message is deleted.
     */
    fun singlePage(pageEditor: CustomPageEditor<CustomPagination>): CustomPaginationBuilder =
        CustomPaginationBuilder(context, 1, pageEditor)

    /**
     * Classic paginator, where each page is generated by a [CustomPageEditor].
     *
     * This is primarily used in combination with [paginationWrapper].
     *
     * In an effort to reduce resource consumption,
     * you should call [AbstractPaginator.cleanup] when the message is deleted.
     */
    fun customPagination(maxPages: Int, pageEditor: CustomPageEditor<CustomPagination>): CustomPaginationBuilder =
        CustomPaginationBuilder(context, maxPages, pageEditor)

    /**
     * Classic paginator, where each page is generated by a [PageEditor].
     *
     * In addition to the content provided, five buttons (first, previous, next, last, (optional) delete)
     * are added to navigate from page to page.
     *
     * In an effort to reduce resource consumption,
     * you should call [AbstractPaginator.cleanup] when the message is deleted.
     */
    fun paginator(maxPages: Int, pageEditor: PageEditor<Paginator>): PaginatorBuilder =
        PaginatorBuilder(context, maxPages, pageEditor)

    /**
     * A paginator where each page is filled with a list of entries.
     *
     * Each page can be limited to [a specified number of entries][AbstractMenuBuilder.maxEntriesPerPage].
     *
     * Each entry can have its [prefix][AbstractMenuBuilder.rowPrefixSupplier]
     * and its [string representation][AbstractMenuBuilder.transformer] customized.
     *
     * In an effort to reduce resource consumption,
     * you should call [AbstractPaginator.cleanup] when the message is deleted.
     */
    fun <E> menu(entries: List<E>): MenuBuilder<E> =
        MenuBuilder(context, entries)

    /**
     * A paginator where each page is filled with a list of entries.
     *
     * Each page can be limited to [a specified number of entries][AbstractMenuBuilder.maxEntriesPerPage].
     *
     * Each entry can have its [prefix][AbstractMenuBuilder.rowPrefixSupplier]
     * and its [string representation][AbstractMenuBuilder.transformer] customized.
     *
     * In addition, each entry is associated to a [Button],
     * when clicked, the [callback][ButtonMenuBuilder.callback] is run.
     *
     * In an effort to reduce resource consumption,
     * you should call [AbstractPaginator.cleanup] when the message is deleted.
     */
    fun <E> buttonMenu(entries: List<E>, styledButtonContentSupplier: StyledButtonContentSupplier<E>, callback: BlockingChoiceCallback<E>): ButtonMenuBuilder<E> =
        ButtonMenuBuilder(context, entries, styledButtonContentSupplier, callback::accept)

    /**
     * A paginator where each page is filled with a list of entries.
     *
     * Each page can be limited to [a specified number of entries][AbstractMenuBuilder.maxEntriesPerPage].
     *
     * Each entry can have its [prefix][AbstractMenuBuilder.rowPrefixSupplier]
     * and its [string representation][AbstractMenuBuilder.transformer] customized.
     *
     * In addition, each entry is associated to a [Button],
     * when clicked, the [callback][ButtonMenuBuilder.callback] is run.
     *
     * In an effort to reduce resource consumption,
     * you should call [AbstractPaginator.cleanup] when the message is deleted.
     */
    @JvmSynthetic
    fun <E> buttonMenu(entries: List<E>, styledButtonContentSupplier: StyledButtonContentSupplier<E>, callback: SuspendingChoiceCallback<E>): ButtonMenuBuilder<E> =
        ButtonMenuBuilder(context, entries, styledButtonContentSupplier, callback)

    /**
     * A paginator which wraps other paginators, with a select menu to switch between them.
     *
     * In an effort to reduce resource consumption,
     * you should call [AbstractPaginator.cleanup] when the message is deleted.
     */
    fun <W : AbstractPagination<W>> paginationWrapper(): PaginationWrapperBuilder<W> =
        PaginationWrapperBuilder(context)

    object Defaults {
        @JvmStatic
        var firstPageButtonContent: ButtonContent = ButtonContent.withShortcode("rewind")
        @JvmStatic
        var previousPageButtonContent: ButtonContent = ButtonContent.withShortcode("arrow_backward")
        @JvmStatic
        var nextPageButtonContent: ButtonContent = ButtonContent.withShortcode("arrow_forward")
        @JvmStatic
        var lastPageButtonContent: ButtonContent = ButtonContent.withShortcode("fast_forward")
        @JvmStatic
        var deleteButtonContent: ButtonContent = ButtonContent.withShortcode("wastebasket")
    }
}