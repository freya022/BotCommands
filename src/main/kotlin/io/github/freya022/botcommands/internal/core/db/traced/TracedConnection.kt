@file:IgnoreStackFrame

package io.github.freya022.botcommands.internal.core.db.traced

import io.github.freya022.botcommands.api.core.db.annotations.IgnoreStackFrame
import io.github.freya022.botcommands.api.core.db.query.ParametrizedQueryFactory
import io.github.freya022.botcommands.internal.core.db.DatabaseImpl
import io.github.oshai.kotlinlogging.KLogger
import io.github.oshai.kotlinlogging.KotlinLogging
import kotlinx.coroutines.sync.Semaphore
import java.lang.reflect.Modifier
import java.sql.Connection
import java.sql.PreparedStatement
import kotlin.time.Duration

private val walker = StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE)

@Suppress("SqlSourceToSinkFlow")
@IgnoreStackFrame
internal class TracedConnection internal constructor(
    connection: Connection,
    semaphore: Semaphore,
    private val parametrizedQueryFactory: ParametrizedQueryFactory<*>,
    private val logQueries: Boolean,
    private val isQueryThresholdSet: Boolean,
    private val queryLogThreshold: Duration
) : DatabaseImpl.ConnectionResource(connection, semaphore) {
    override fun prepareStatement(sql: String): PreparedStatement {
        return wrapStatement(connection.prepareStatement(sql), sql)
    }

    override fun prepareStatement(sql: String, columnNames: Array<out String>): PreparedStatement {
        return wrapStatement(connection.prepareStatement(sql, columnNames), sql)
    }

    override fun prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int): PreparedStatement {
        return wrapStatement(connection.prepareStatement(sql, resultSetType, resultSetConcurrency), sql)
    }

    override fun prepareStatement(sql: String, autoGeneratedKeys: Int): PreparedStatement {
        return wrapStatement(connection.prepareStatement(sql, autoGeneratedKeys), sql)
    }

    override fun prepareStatement(sql: String, columnIndexes: IntArray): PreparedStatement {
        return wrapStatement(connection.prepareStatement(sql, columnIndexes), sql)
    }

    override fun prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): PreparedStatement {
        return wrapStatement(connection.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability), sql)
    }

    private fun wrapStatement(preparedStatement: PreparedStatement, sql: String): PreparedStatement {
        val logger = loggerFromCallStack()
        return if (isQueryThresholdSet || (logQueries && logger.isTraceEnabled())) {
            val tracedQuery = parametrizedQueryFactory.get(preparedStatement, sql)
            TracedPreparedStatement(preparedStatement, logger, tracedQuery, logQueries, isQueryThresholdSet, queryLogThreshold)
        } else {
            preparedStatement
        }
    }
}

private fun loggerFromCallStack(): KLogger {
    return walker.walk { stream ->
        stream.skip(1)
            .map { it.declaringClass }
            .dropWhile { it.isAnnotationPresent(IgnoreStackFrame::class.java) }
            .findAny().get()
    }.toUnwrappedLogger()
}

private fun Class<*>.toUnwrappedLogger(): KLogger {
    val className = unwrapCompanionClass(this).name.substringBefore('$')
    return KotlinLogging.logger(className)
}

private fun <T : Any> unwrapCompanionClass(clazz: Class<T>): Class<*> {
    val enclosingClass = clazz.enclosingClass ?: return clazz

    val hasCompanionField = enclosingClass.declaredFields.any { field ->
        field.name == clazz.simpleName &&
                Modifier.isStatic(field.modifiers) &&
                field.type == clazz
    }

    return when {
        hasCompanionField -> enclosingClass
        else -> clazz
    }
}