package io.github.freya022.botcommands.internal.core.db.traced

import io.github.freya022.botcommands.api.core.db.query.ParametrizedQueryFactory
import io.github.oshai.kotlinlogging.KLogger
import io.github.oshai.kotlinlogging.KotlinLogging
import java.lang.reflect.Modifier
import java.sql.Connection
import java.sql.PreparedStatement
import kotlin.streams.asSequence
import kotlin.time.Duration

private val walker = StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE)

@Suppress("SqlSourceToSinkFlow")
internal class TracedConnection internal constructor(
    private val connection: Connection,
    private val parametrizedQueryFactory: ParametrizedQueryFactory<*>,
    private val isQueryThresholdSet: Boolean,
    private val queryLogThreshold: Duration
) : Connection by connection {
    override fun prepareStatement(sql: String): PreparedStatement {
        return wrapStatement(connection.prepareStatement(sql), sql)
    }

    override fun prepareStatement(sql: String, columnNames: Array<out String>): PreparedStatement {
        return wrapStatement(connection.prepareStatement(sql, columnNames), sql)
    }

    override fun prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int): PreparedStatement {
        return wrapStatement(connection.prepareStatement(sql, resultSetType, resultSetConcurrency), sql)
    }

    override fun prepareStatement(sql: String, autoGeneratedKeys: Int): PreparedStatement {
        return wrapStatement(connection.prepareStatement(sql, autoGeneratedKeys), sql)
    }

    override fun prepareStatement(sql: String, columnIndexes: IntArray): PreparedStatement {
        return wrapStatement(connection.prepareStatement(sql, columnIndexes), sql)
    }

    override fun prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): PreparedStatement {
        return wrapStatement(connection.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability), sql)
    }

    private fun wrapStatement(preparedStatement: PreparedStatement, sql: String): PreparedStatement {
        val logger = getLogger()
        return if (logger.isTraceEnabled()) {
            val tracedQuery = parametrizedQueryFactory.get(preparedStatement, sql)
            TracedPreparedStatement(preparedStatement, logger, tracedQuery, isQueryThresholdSet, queryLogThreshold)
        } else {
            preparedStatement
        }
    }

    private fun getLogger(): KLogger {
        // 1. getLogger
        // 2. wrapStatement
        // 3. prepareStatement
        // 4. Class generated for coroutines (prepareStatement:-1)
        // 5 ==> invokeSuspend, ClassWeLookingFor$TheMethod
        val callerClass = walker.walk { stream -> stream.asSequence().drop(4).first().declaringClass }
        val callerClassName = unwrapCompanionClass(callerClass).name.substringBefore('$')
        return KotlinLogging.logger(callerClassName)
    }

    private fun <T : Any> unwrapCompanionClass(clazz: Class<T>): Class<*> {
        val enclosingClass = clazz.enclosingClass ?: return clazz

        val hasCompanionField = enclosingClass.declaredFields.any { field ->
            field.name == clazz.simpleName &&
                    Modifier.isStatic(field.modifiers) &&
                    field.type == clazz
        }

        return when {
            hasCompanionField -> enclosingClass
            else -> clazz
        }
    }
}